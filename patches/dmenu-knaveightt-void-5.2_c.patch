diff -Np1 dmenu-5.2/config.def.h patched_dmenu/config.def.h
*** dmenu-5.2/config.def.h	2023-03-17 07:28:03.338950800 -0400
--- patched_dmenu/config.def.h	2023-03-17 07:53:48.044902481 -0400
***************
*** 4,5 ****
--- 4,7 ----
  static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
+ static int centered = 0;                    /* -c option; centers dmenu on screen */
+ static int min_width = 500;                    /* minimum width when centered */
  /* -fn option overrides fonts[0]; default X11 font or font set */
*************** static const char *colors[SchemeLast][2]
*** 13,15 ****
--- 15,20 ----
  	[SchemeSel] = { "#eeeeee", "#005577" },
+ 	[SchemeSelHighlight] = { "#ffc978", "#005577" },
+ 	[SchemeNormHighlight] = { "#ffc978", "#222222" },
  	[SchemeOut] = { "#000000", "#00ffff" },
+ 	[SchemeOutHighlight] = { "#ffc978", "#00ffff" },
  };
*************** static const char *colors[SchemeLast][2]
*** 17,18 ****
--- 22,26 ----
  static unsigned int lines      = 0;
+ /* -h option; minimum height of a menu line */
+ static unsigned int lineheight = 0;
+ static unsigned int min_lineheight = 8;
  
*************** static unsigned int lines      = 0;
*** 23 ****
--- 31,39 ----
  static const char worddelimiters[] = " ";
+ 
+ /* Size of the window border */
+ static unsigned int border_width = 0;
+ 
+ /* tsv-alt: reverse the order of tab separation.
+  * 0 = display<TAB>output. 1 = output<TAB>display
+  * can be reversed with -r as well */
+ static int revtab = 0;
diff -Np1 dmenu-5.2/config.def.h.orig patched_dmenu/config.def.h.orig
*** dmenu-5.2/config.def.h.orig	1969-12-31 19:00:00.000000000 -0500
--- patched_dmenu/config.def.h.orig	2023-03-17 07:52:18.475905283 -0400
***************
*** 0 ****
--- 1,36 ----
+ /* See LICENSE file for copyright and license details. */
+ /* Default settings; can be overriden by command line. */
+ 
+ static int topbar = 1;                      /* -b  option; if 0, dmenu appears at bottom     */
+ static int centered = 0;                    /* -c option; centers dmenu on screen */
+ static int min_width = 500;                    /* minimum width when centered */
+ /* -fn option overrides fonts[0]; default X11 font or font set */
+ static const char *fonts[] = {
+ 	"monospace:size=10"
+ };
+ static const char *prompt      = NULL;      /* -p  option; prompt to the left of input field */
+ static const char *colors[SchemeLast][2] = {
+ 	/*     fg         bg       */
+ 	[SchemeNorm] = { "#bbbbbb", "#222222" },
+ 	[SchemeSel] = { "#eeeeee", "#005577" },
+ 	[SchemeSelHighlight] = { "#ffc978", "#005577" },
+ 	[SchemeNormHighlight] = { "#ffc978", "#222222" },
+ 	[SchemeOut] = { "#000000", "#00ffff" },
+ 	[SchemeOutHighlight] = { "#ffc978", "#00ffff" },
+ };
+ /* -l option; if nonzero, dmenu uses vertical list with given number of lines */
+ static unsigned int lines      = 0;
+ /* -h option; minimum height of a menu line */
+ static unsigned int lineheight = 0;
+ static unsigned int min_lineheight = 8;
+ 
+ /*
+  * Characters not considered part of a word while deleting words
+  * for example: " /?\"&[]"
+  */
+ static const char worddelimiters[] = " ";
+ 
+ /* tsv-alt: reverse the order of tab separation.
+  * 0 = display<TAB>output. 1 = output<TAB>display
+  * can be reversed with -r as well */
+ static int revtab = 0;
diff -Np1 dmenu-5.2/dmenu.1 patched_dmenu/dmenu.1
*** dmenu-5.2/dmenu.1	2023-03-17 07:28:03.338950800 -0400
--- patched_dmenu/dmenu.1	2023-03-17 07:39:31.548929273 -0400
*************** dmenu \- dynamic menu
*** 5,11 ****
  .B dmenu
! .RB [ \-bfiv ]
  .RB [ \-l
  .IR lines ]
  .RB [ \-m
  .IR monitor ]
  .RB [ \-p
--- 5,19 ----
  .B dmenu
! .RB [ \-bfivr ]
  .RB [ \-l
  .IR lines ]
+ .RB [ \-h
+ .IR height ]
  .RB [ \-m
  .IR monitor ]
+ .RB [ \-x
+ .IR xoffset ]
+ .RB [ \-y
+ .IR yoffset ]
+ .RB [ \-z
+ .IR width ]
  .RB [ \-p
*************** dmenu appears at the bottom of the scree
*** 42,43 ****
--- 50,54 ----
  .TP
+ .B \-c
+ dmenu appears centered on the screen.
+ .TP
  .B \-f
*************** dmenu lists items vertically, with the g
*** 52,53 ****
--- 63,67 ----
  .TP
+ .BI \-h " height"
+ dmenu uses a menu line of at least 'height' pixels tall, but no less than 8.
+ .TP
  .BI \-m " monitor"
*************** from 0.
*** 56,57 ****
--- 70,89 ----
  .TP
+ .BI \-x " xoffset"
+ dmenu is placed at this offset measured from the left side of the monitor.
+ Can be negative.
+ If option
+ .B \-m
+ is present, the measurement will use the given monitor.
+ .TP
+ .BI \-y " yoffset"
+ dmenu is placed at this offset measured from the top of the monitor.  If the
+ .B \-b
+ option is used, the offset is measured from the bottom.  Can be negative.
+ If option
+ .B \-m
+ is present, the measurement will use the given monitor.
+ .TP
+ .BI \-z " width"
+ sets the width of the dmenu window.
+ .TP
  .BI \-p " prompt"
*************** prints version information to stdout, th
*** 82,83 ****
--- 114,119 ----
  embed into windowid.
+ .TP
+ .B \-r
+ tsv-alt: reverse the behavior of tab separation.
+ .TP
  .SH USAGE
diff -Np1 dmenu-5.2/dmenu.1.orig patched_dmenu/dmenu.1.orig
*** dmenu-5.2/dmenu.1.orig	1969-12-31 19:00:00.000000000 -0500
--- patched_dmenu/dmenu.1.orig	2023-03-17 07:35:30.336936818 -0400
***************
*** 0 ****
--- 1,227 ----
+ .TH DMENU 1 dmenu\-VERSION
+ .SH NAME
+ dmenu \- dynamic menu
+ .SH SYNOPSIS
+ .B dmenu
+ .RB [ \-bfivr ]
+ .RB [ \-l
+ .IR lines ]
+ .RB [ \-h
+ .IR height ]
+ .RB [ \-m
+ .IR monitor ]
+ .RB [ \-x
+ .IR xoffset ]
+ .RB [ \-y
+ .IR yoffset ]
+ .RB [ \-z
+ .IR width ]
+ .RB [ \-p
+ .IR prompt ]
+ .RB [ \-fn
+ .IR font ]
+ .RB [ \-nb
+ .IR color ]
+ .RB [ \-nf
+ .IR color ]
+ .RB [ \-sb
+ .IR color ]
+ .RB [ \-sf
+ .IR color ]
+ .RB [ \-w
+ .IR windowid ]
+ .P
+ .BR dmenu_run " ..."
+ .SH DESCRIPTION
+ .B dmenu
+ is a dynamic menu for X, which reads a list of newline\-separated items from
+ stdin.  When the user selects an item and presses Return, their choice is printed
+ to stdout and dmenu terminates.  Entering text will narrow the items to those
+ matching the tokens in the input.
+ .P
+ .B dmenu_run
+ is a script used by
+ .IR dwm (1)
+ which lists programs in the user's $PATH and runs the result in their $SHELL.
+ .SH OPTIONS
+ .TP
+ .B \-b
+ dmenu appears at the bottom of the screen.
+ .TP
+ .B \-f
+ dmenu grabs the keyboard before reading stdin if not reading from a tty. This
+ is faster, but will lock up X until stdin reaches end\-of\-file.
+ .TP
+ .B \-i
+ dmenu matches menu items case insensitively.
+ .TP
+ .BI \-l " lines"
+ dmenu lists items vertically, with the given number of lines.
+ .TP
+ .BI \-h " height"
+ dmenu uses a menu line of at least 'height' pixels tall, but no less than 8.
+ .TP
+ .BI \-m " monitor"
+ dmenu is displayed on the monitor number supplied. Monitor numbers are starting
+ from 0.
+ .TP
+ .BI \-x " xoffset"
+ dmenu is placed at this offset measured from the left side of the monitor.
+ Can be negative.
+ If option
+ .B \-m
+ is present, the measurement will use the given monitor.
+ .TP
+ .BI \-y " yoffset"
+ dmenu is placed at this offset measured from the top of the monitor.  If the
+ .B \-b
+ option is used, the offset is measured from the bottom.  Can be negative.
+ If option
+ .B \-m
+ is present, the measurement will use the given monitor.
+ .TP
+ .BI \-z " width"
+ sets the width of the dmenu window.
+ .TP
+ .BI \-p " prompt"
+ defines the prompt to be displayed to the left of the input field.
+ .TP
+ .BI \-fn " font"
+ defines the font or font set used.
+ .TP
+ .BI \-nb " color"
+ defines the normal background color.
+ .IR #RGB ,
+ .IR #RRGGBB ,
+ and X color names are supported.
+ .TP
+ .BI \-nf " color"
+ defines the normal foreground color.
+ .TP
+ .BI \-sb " color"
+ defines the selected background color.
+ .TP
+ .BI \-sf " color"
+ defines the selected foreground color.
+ .TP
+ .B \-v
+ prints version information to stdout, then exits.
+ .TP
+ .BI \-w " windowid"
+ embed into windowid.
+ .TP
+ .B \-r
+ tsv-alt: reverse the behavior of tab separation.
+ .TP
+ .SH USAGE
+ dmenu is completely controlled by the keyboard.  Items are selected using the
+ arrow keys, page up, page down, home, and end.
+ .TP
+ .B Tab
+ Copy the selected item to the input field.
+ .TP
+ .B Return
+ Confirm selection.  Prints the selected item to stdout and exits, returning
+ success.
+ .TP
+ .B Ctrl-Return
+ Confirm selection.  Prints the selected item to stdout and continues.
+ .TP
+ .B Shift\-Return
+ Confirm input.  Prints the input text to stdout and exits, returning success.
+ .TP
+ .B Escape
+ Exit without selecting an item, returning failure.
+ .TP
+ .B Ctrl-Left
+ Move cursor to the start of the current word
+ .TP
+ .B Ctrl-Right
+ Move cursor to the end of the current word
+ .TP
+ .B C\-a
+ Home
+ .TP
+ .B C\-b
+ Left
+ .TP
+ .B C\-c
+ Escape
+ .TP
+ .B C\-d
+ Delete
+ .TP
+ .B C\-e
+ End
+ .TP
+ .B C\-f
+ Right
+ .TP
+ .B C\-g
+ Escape
+ .TP
+ .B C\-h
+ Backspace
+ .TP
+ .B C\-i
+ Tab
+ .TP
+ .B C\-j
+ Return
+ .TP
+ .B C\-J
+ Shift-Return
+ .TP
+ .B C\-k
+ Delete line right
+ .TP
+ .B C\-m
+ Return
+ .TP
+ .B C\-M
+ Shift-Return
+ .TP
+ .B C\-n
+ Down
+ .TP
+ .B C\-p
+ Up
+ .TP
+ .B C\-u
+ Delete line left
+ .TP
+ .B C\-w
+ Delete word left
+ .TP
+ .B C\-y
+ Paste from primary X selection
+ .TP
+ .B C\-Y
+ Paste from X clipboard
+ .TP
+ .B M\-b
+ Move cursor to the start of the current word
+ .TP
+ .B M\-f
+ Move cursor to the end of the current word
+ .TP
+ .B M\-g
+ Home
+ .TP
+ .B M\-G
+ End
+ .TP
+ .B M\-h
+ Up
+ .TP
+ .B M\-j
+ Page down
+ .TP
+ .B M\-k
+ Page up
+ .TP
+ .B M\-l
+ Down
+ .SH SEE ALSO
+ .IR dwm (1),
+ .IR stest (1)
diff -Np1 dmenu-5.2/dmenu.c patched_dmenu/dmenu.c
*** dmenu-5.2/dmenu.c	2023-03-17 07:28:03.339950800 -0400
--- patched_dmenu/dmenu.c	2023-03-17 07:58:11.164894251 -0400
***************
*** 17,18 ****
--- 17,19 ----
  #include <X11/Xft/Xft.h>
+ #include <X11/Xresource.h>
  
***************
*** 28,33 ****
  /* enums */
! enum { SchemeNorm, SchemeSel, SchemeOut, SchemeLast }; /* color schemes */
! 
  struct item {
  	char *text;
  	struct item *left, *right;
--- 29,34 ----
  /* enums */
! enum { SchemeNorm, SchemeSel, SchemeOut, SchemeNormHighlight, SchemeSelHighlight, SchemeOutHighlight, SchemeLast }; /* color schemes */
  struct item {
  	char *text;
+ 	char *otext;
  	struct item *left, *right;
*************** static char *embed;
*** 39,40 ****
--- 40,44 ----
  static int bh, mw, mh;
+ static int dmx = 0; /* put dmenu at this x offset */
+ static int dmy = 0; /* put dmenu at this y offset (measured from the bottom if topbar is 0) */
+ static unsigned int dmw = 0; /* make dmenu this wide */
  static int inputw = 0, promptw;
*************** static Clr *scheme[SchemeLast];
*** 55,56 ****
--- 59,64 ----
  
+ /* Temporary arrays to allow overriding xresources values */
+ static char *colortemp[4];
+ static char *tempfonts;
+ 
  #include "config.h"
*************** calcoffsets(void)
*** 98,99 ****
--- 106,116 ----
  
+ static int
+ max_textw(void)
+ {
+ 	int len = 0;
+ 	for (struct item *item = items; item && item->text; item++)
+ 		len = MAX(TEXTW(item->text), len);
+ 	return len;
+ }
+ 
  static void
*************** cleanup(void)
*** 107,109 ****
  	for (i = 0; items && items[i].text; ++i)
! 		free(items[i].text);
  	free(items);
--- 124,126 ----
  	for (i = 0; items && items[i].text; ++i)
! 		free(revtab ? items[i].otext : items[i].text);
  	free(items);
*************** cistrstr(const char *h, const char *n)
*** 132,133 ****
--- 149,187 ----
  
+ static void
+ drawhighlights(struct item *item, int x, int y, int maxw)
+ {
+ 	char restorechar, tokens[sizeof text], *highlight,  *token;
+ 	int indentx, highlightlen;
+ 
+ 	drw_setscheme(drw, scheme[item == sel ? SchemeSelHighlight : item->out ? SchemeOutHighlight : SchemeNormHighlight]);
+ 	strcpy(tokens, text);
+ 	for (token = strtok(tokens, " "); token; token = strtok(NULL, " ")) {
+ 		highlight = fstrstr(item->text, token);
+ 		while (highlight) {
+ 			// Move item str end, calc width for highlight indent, & restore
+ 			highlightlen = highlight - item->text;
+ 			restorechar = *highlight;
+ 			item->text[highlightlen] = '\0';
+ 			indentx = TEXTW(item->text);
+ 			item->text[highlightlen] = restorechar;
+ 
+ 			// Move highlight str end, draw highlight, & restore
+ 			restorechar = highlight[strlen(token)];
+ 			highlight[strlen(token)] = '\0';
+ 			if (indentx - (lrpad / 2) - 1 < maxw)
+ 				drw_text(
+ 					drw,
+ 					x + indentx - (lrpad / 2) - 1,
+ 					y,
+ 					MIN(maxw - indentx, TEXTW(highlight) - lrpad),
+ 					bh, 0, highlight, 0
+ 				);
+ 			highlight[strlen(token)] = restorechar;
+ 
+ 			if (strlen(highlight) - strlen(token) < strlen(token)) break;
+ 			highlight = fstrstr(highlight + strlen(token), token);
+ 		}
+ 	}
+ }
+ 
  static int
*************** drawitem(struct item *item, int x, int y
*** 142,144 ****
  
! 	return drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
  }
--- 196,200 ----
  
! 	int r = drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
! 	drawhighlights(item, x, y, w);
! 	return r;
  }
*************** drawmenu(void)
*** 150,152 ****
  	struct item *item;
! 	int x = 0, y = 0, w;
  
--- 206,208 ----
  	struct item *item;
! 	int x = 0, y = 0, fh = drw->fonts->h, w;
  
*************** drawmenu(void)
*** 167,169 ****
  		drw_setscheme(drw, scheme[SchemeNorm]);
! 		drw_rect(drw, x + curpos, 2, 2, bh - 4, 1, 0);
  	}
--- 223,225 ----
  		drw_setscheme(drw, scheme[SchemeNorm]);
! 		drw_rect(drw, x + curpos, 2 + (bh - fh) / 2, 2, fh - 4, 1, 0);
  	}
*************** drawmenu(void)
*** 173,175 ****
  		for (item = curr; item != next; item = item->right)
! 			drawitem(item, x, y += bh, mw - x);
  	} else if (matches) {
--- 229,231 ----
  		for (item = curr; item != next; item = item->right)
! 			drawitem(item, x - promptw, y += bh, mw);
  	} else if (matches) {
*************** insert:
*** 492,494 ****
  	case XK_KP_Enter:
! 		puts((sel && !(ev->state & ShiftMask)) ? sel->text : text);
  		if (!(ev->state & ControlMask)) {
--- 548,550 ----
  	case XK_KP_Enter:
! 		puts((sel && !(ev->state & ShiftMask)) ? sel->otext : text);
  		if (!(ev->state & ControlMask)) {
*************** readstdin(void)
*** 562,564 ****
  			line[len - 1] = '\0';
! 		items[i].text = line;
  		items[i].out = 0;
--- 618,624 ----
  			line[len - 1] = '\0';
! 		items[i].text = items[i].otext = line;
! 		if ((line = strchr(line, '\t'))) {
! 			*line++ = '\0';
! 			revtab ? (items[i].text = line) : (items[i].otext = line);
! 		}
  		items[i].out = 0;
*************** readstdin(void)
*** 566,568 ****
  	if (items)
! 		items[i].text = NULL;
  	lines = MIN(lines, i);
--- 626,628 ----
  	if (items)
! 		items[i].text = items[i].otext = NULL;
  	lines = MIN(lines, i);
*************** setup(void)
*** 624,627 ****
  	/* init appearance */
! 	for (j = 0; j < SchemeLast; j++)
! 		scheme[j] = drw_scm_create(drw, colors[j], 2);
  
--- 684,692 ----
  	/* init appearance */
! 	for (j = 0; j < SchemeLast; j++) {
! 		scheme[j] = drw_scm_create(drw, (const char**)colors[j], 2);
! 	}
! 	for (j = 0; j < SchemeOut; ++j) {
! 		for (i = 0; i < 2; ++i)
! 			free(colors[j][i]);
! 	}
  
*************** setup(void)
*** 632,635 ****
--- 697,702 ----
  	bh = drw->fonts->h + 2;
+ 	bh = MAX(bh,lineheight);	/* make a menu line AT LEAST 'lineheight' tall */
  	lines = MAX(lines, 0);
  	mh = (lines + 1) * bh;
+ 	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
  #ifdef XINERAMA
*************** setup(void)
*** 660,664 ****
  
! 		x = info[i].x_org;
! 		y = info[i].y_org + (topbar ? 0 : info[i].height - mh);
! 		mw = info[i].width;
  		XFree(info);
--- 727,737 ----
  
!         if (centered) {
!             mw = MIN(MAX(max_textw() + promptw, min_width), info[i].width);
! 			x = info[i].x_org + ((info[i].width  - mw) / 2);
! 			y = info[i].y_org + ((info[i].height - mh) / 2);
!         } else {
! 		    x = info[i].x_org + dmx;
! 		    y = info[i].y_org + (topbar ? dmy : info[i].height - mh - dmy);
! 		    mw = (dmw>0 ? dmw : info[i].width);
!         }
  		XFree(info);
*************** setup(void)
*** 670,674 ****
  			    parentwin);
! 		x = 0;
! 		y = topbar ? 0 : wa.height - mh;
! 		mw = wa.width;
  	}
--- 743,753 ----
  			    parentwin);
!         if (centered) {
!             mw = MIN(MAX(max_textw() + promptw, min_width), wa.width);
! 			x = (wa.width  - mw) / 2;
! 			y = (wa.height - mh) / 2;
!         } else {
! 		    x = dmx;
! 		    y = topbar ? dmy : wa.height - mh - dmy;
! 		    mw = (dmw>0 ? dmw : wa.width);
!         }
  	}
*************** setup(void)
*** 682,686 ****
  	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
! 	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, 0,
  	                    CopyFromParent, CopyFromParent, CopyFromParent,
  	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
  	XSetClassHint(dpy, win, &ch);
--- 761,767 ----
  	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
! 	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, border_width,
  	                    CopyFromParent, CopyFromParent, CopyFromParent,
  	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
+ 	if (border_width)
+ 		XSetWindowBorder(dpy, win, scheme[SchemeSel][ColBg].pixel);
  	XSetClassHint(dpy, win, &ch);
*************** usage(void)
*** 712,714 ****
  {
! 	die("usage: dmenu [-bfiv] [-l lines] [-p prompt] [-fn font] [-m monitor]\n"
  	    "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
--- 793,796 ----
  {
! 	die("usage: dmenu [-bfivr] [-l lines] [-h height] [-p prompt] [-fn font] [-m monitor]\n"
!         "             [-x xoffset] [-y yoffset] [-z width]\n"
  	    "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
*************** usage(void)
*** 716,717 ****
--- 798,834 ----
  
+ void
+ readxresources(void) {
+ 	XrmInitialize();
+ 
+ 	char* xrm;
+ 	if ((xrm = XResourceManagerString(drw->dpy))) {
+ 		char *type;
+ 		XrmDatabase xdb = XrmGetStringDatabase(xrm);
+ 		XrmValue xval;
+ 
+ 		if (XrmGetResource(xdb, "dmenu.font", "*", &type, &xval))
+ 			fonts[0] = strdup(xval.addr);
+ 		else
+ 			fonts[0] = strdup(fonts[0]);
+ 		if (XrmGetResource(xdb, "dmenu.background", "*", &type, &xval))
+ 			colors[SchemeNorm][ColBg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeNorm][ColBg] = strdup(colors[SchemeNorm][ColBg]);
+ 		if (XrmGetResource(xdb, "dmenu.foreground", "*", &type, &xval))
+ 			colors[SchemeNorm][ColFg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeNorm][ColFg] = strdup(colors[SchemeNorm][ColFg]);
+ 		if (XrmGetResource(xdb, "dmenu.selbackground", "*", &type, &xval))
+ 			colors[SchemeSel][ColBg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeSel][ColBg] = strdup(colors[SchemeSel][ColBg]);
+ 		if (XrmGetResource(xdb, "dmenu.selforeground", "*", &type, &xval))
+ 			colors[SchemeSel][ColFg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeSel][ColFg] = strdup(colors[SchemeSel][ColFg]);
+ 
+ 		XrmDestroyDatabase(xdb);
+ 	}
+ }
+ 
  int
*************** main(int argc, char *argv[])
*** 731,732 ****
--- 848,851 ----
  			fast = 1;
+ 		else if (!strcmp(argv[i], "-c"))   /* centers dmenu on screen */
+ 			centered = 1;
  		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
*************** main(int argc, char *argv[])
*** 734,736 ****
  			fstrstr = cistrstr;
! 		} else if (i + 1 == argc)
  			usage();
--- 853,857 ----
  			fstrstr = cistrstr;
! 		} else if (!strcmp(argv[i], "-r")) /* reverse the tab separation */
! 			revtab = (!revtab);
! 		else if (i + 1 == argc)
  			usage();
*************** main(int argc, char *argv[])
*** 739,740 ****
--- 860,871 ----
  			lines = atoi(argv[++i]);
+         else if (!strcmp(argv[i], "-x"))   /* window x offset */
+ 			dmx = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-y"))   /* window y offset (from bottom up if -b) */
+ 			dmy = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-z"))   /* make dmenu this wide */
+ 			dmw = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-h")) { /* minimum height of one menu line */
+ 			lineheight = atoi(argv[++i]);
+ 			lineheight = MAX(lineheight, min_lineheight);
+ 		}
  		else if (!strcmp(argv[i], "-m"))
*************** main(int argc, char *argv[])
*** 744,756 ****
  		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
! 			fonts[0] = argv[++i];
  		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
! 			colors[SchemeNorm][ColBg] = argv[++i];
  		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
! 			colors[SchemeNorm][ColFg] = argv[++i];
  		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
! 			colors[SchemeSel][ColBg] = argv[++i];
  		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
! 			colors[SchemeSel][ColFg] = argv[++i];
  		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
  			embed = argv[++i];
  		else
--- 875,889 ----
  		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
! 			tempfonts = argv[++i];
  		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
! 			colortemp[0] = argv[++i];
  		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
! 			colortemp[1] = argv[++i];
  		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
! 			colortemp[2] = argv[++i];
  		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
! 			colortemp[3] = argv[++i];
  		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
  			embed = argv[++i];
+ 		else if (!strcmp(argv[i], "-bw"))
+ 			border_width = atoi(argv[++i]); /* border width */
  		else
*************** main(int argc, char *argv[])
*** 770,773 ****
  	drw = drw_create(dpy, screen, root, wa.width, wa.height);
! 	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
  		die("no fonts could be loaded.");
  	lrpad = drw->fonts->h;
--- 903,921 ----
  	drw = drw_create(dpy, screen, root, wa.width, wa.height);
! 	readxresources();
! 	/* Now we check whether to override xresources with commandline parameters */
! 	if ( tempfonts )
! 	   fonts[0] = strdup(tempfonts);
! 	if ( colortemp[0])
! 	   colors[SchemeNorm][ColBg] = strdup(colortemp[0]);
! 	if ( colortemp[1])
! 	   colors[SchemeNorm][ColFg] = strdup(colortemp[1]);
! 	if ( colortemp[2])
! 	   colors[SchemeSel][ColBg]  = strdup(colortemp[2]);
! 	if ( colortemp[3])
! 	   colors[SchemeSel][ColFg]  = strdup(colortemp[3]);
! 
! 	if (!drw_fontset_create(drw, (const char**)fonts, LENGTH(fonts)))
  		die("no fonts could be loaded.");
+ 
+ 	free(fonts[0]);
  	lrpad = drw->fonts->h;
diff -Np1 dmenu-5.2/dmenu.c.orig patched_dmenu/dmenu.c.orig
*** dmenu-5.2/dmenu.c.orig	1969-12-31 19:00:00.000000000 -0500
--- patched_dmenu/dmenu.c.orig	2023-03-17 07:52:18.476905283 -0400
***************
*** 0 ****
--- 1,939 ----
+ /* See LICENSE file for copyright and license details. */
+ #include <ctype.h>
+ #include <locale.h>
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <string.h>
+ #include <strings.h>
+ #include <time.h>
+ #include <unistd.h>
+ 
+ #include <X11/Xlib.h>
+ #include <X11/Xatom.h>
+ #include <X11/Xutil.h>
+ #ifdef XINERAMA
+ #include <X11/extensions/Xinerama.h>
+ #endif
+ #include <X11/Xft/Xft.h>
+ #include <X11/Xresource.h>
+ 
+ #include "drw.h"
+ #include "util.h"
+ 
+ /* macros */
+ #define INTERSECT(x,y,w,h,r)  (MAX(0, MIN((x)+(w),(r).x_org+(r).width)  - MAX((x),(r).x_org)) \
+                              * MAX(0, MIN((y)+(h),(r).y_org+(r).height) - MAX((y),(r).y_org)))
+ #define LENGTH(X)             (sizeof X / sizeof X[0])
+ #define TEXTW(X)              (drw_fontset_getwidth(drw, (X)) + lrpad)
+ 
+ /* enums */
+ enum { SchemeNorm, SchemeSel, SchemeOut, SchemeNormHighlight, SchemeSelHighlight, SchemeOutHighlight, SchemeLast }; /* color schemes */
+ struct item {
+ 	char *text;
+ 	char *otext;
+ 	struct item *left, *right;
+ 	int out;
+ };
+ 
+ static char text[BUFSIZ] = "";
+ static char *embed;
+ static int bh, mw, mh;
+ static int dmx = 0; /* put dmenu at this x offset */
+ static int dmy = 0; /* put dmenu at this y offset (measured from the bottom if topbar is 0) */
+ static unsigned int dmw = 0; /* make dmenu this wide */
+ static int inputw = 0, promptw;
+ static int lrpad; /* sum of left and right padding */
+ static size_t cursor;
+ static struct item *items = NULL;
+ static struct item *matches, *matchend;
+ static struct item *prev, *curr, *next, *sel;
+ static int mon = -1, screen;
+ 
+ static Atom clip, utf8;
+ static Display *dpy;
+ static Window root, parentwin, win;
+ static XIC xic;
+ 
+ static Drw *drw;
+ static Clr *scheme[SchemeLast];
+ 
+ /* Temporary arrays to allow overriding xresources values */
+ static char *colortemp[4];
+ static char *tempfonts;
+ 
+ #include "config.h"
+ 
+ static int (*fstrncmp)(const char *, const char *, size_t) = strncmp;
+ static char *(*fstrstr)(const char *, const char *) = strstr;
+ 
+ static unsigned int
+ textw_clamp(const char *str, unsigned int n)
+ {
+ 	unsigned int w = drw_fontset_getwidth_clamp(drw, str, n) + lrpad;
+ 	return MIN(w, n);
+ }
+ 
+ static void
+ appenditem(struct item *item, struct item **list, struct item **last)
+ {
+ 	if (*last)
+ 		(*last)->right = item;
+ 	else
+ 		*list = item;
+ 
+ 	item->left = *last;
+ 	item->right = NULL;
+ 	*last = item;
+ }
+ 
+ static void
+ calcoffsets(void)
+ {
+ 	int i, n;
+ 
+ 	if (lines > 0)
+ 		n = lines * bh;
+ 	else
+ 		n = mw - (promptw + inputw + TEXTW("<") + TEXTW(">"));
+ 	/* calculate which items will begin the next page and previous page */
+ 	for (i = 0, next = curr; next; next = next->right)
+ 		if ((i += (lines > 0) ? bh : textw_clamp(next->text, n)) > n)
+ 			break;
+ 	for (i = 0, prev = curr; prev && prev->left; prev = prev->left)
+ 		if ((i += (lines > 0) ? bh : textw_clamp(prev->left->text, n)) > n)
+ 			break;
+ }
+ 
+ static int
+ max_textw(void)
+ {
+ 	int len = 0;
+ 	for (struct item *item = items; item && item->text; item++)
+ 		len = MAX(TEXTW(item->text), len);
+ 	return len;
+ }
+ 
+ static void
+ cleanup(void)
+ {
+ 	size_t i;
+ 
+ 	XUngrabKey(dpy, AnyKey, AnyModifier, root);
+ 	for (i = 0; i < SchemeLast; i++)
+ 		free(scheme[i]);
+ 	for (i = 0; items && items[i].text; ++i)
+ 		free(revtab ? items[i].otext : items[i].text);
+ 	free(items);
+ 	drw_free(drw);
+ 	XSync(dpy, False);
+ 	XCloseDisplay(dpy);
+ }
+ 
+ static char *
+ cistrstr(const char *h, const char *n)
+ {
+ 	size_t i;
+ 
+ 	if (!n[0])
+ 		return (char *)h;
+ 
+ 	for (; *h; ++h) {
+ 		for (i = 0; n[i] && tolower((unsigned char)n[i]) ==
+ 		            tolower((unsigned char)h[i]); ++i)
+ 			;
+ 		if (n[i] == '\0')
+ 			return (char *)h;
+ 	}
+ 	return NULL;
+ }
+ 
+ static void
+ drawhighlights(struct item *item, int x, int y, int maxw)
+ {
+ 	char restorechar, tokens[sizeof text], *highlight,  *token;
+ 	int indentx, highlightlen;
+ 
+ 	drw_setscheme(drw, scheme[item == sel ? SchemeSelHighlight : item->out ? SchemeOutHighlight : SchemeNormHighlight]);
+ 	strcpy(tokens, text);
+ 	for (token = strtok(tokens, " "); token; token = strtok(NULL, " ")) {
+ 		highlight = fstrstr(item->text, token);
+ 		while (highlight) {
+ 			// Move item str end, calc width for highlight indent, & restore
+ 			highlightlen = highlight - item->text;
+ 			restorechar = *highlight;
+ 			item->text[highlightlen] = '\0';
+ 			indentx = TEXTW(item->text);
+ 			item->text[highlightlen] = restorechar;
+ 
+ 			// Move highlight str end, draw highlight, & restore
+ 			restorechar = highlight[strlen(token)];
+ 			highlight[strlen(token)] = '\0';
+ 			if (indentx - (lrpad / 2) - 1 < maxw)
+ 				drw_text(
+ 					drw,
+ 					x + indentx - (lrpad / 2) - 1,
+ 					y,
+ 					MIN(maxw - indentx, TEXTW(highlight) - lrpad),
+ 					bh, 0, highlight, 0
+ 				);
+ 			highlight[strlen(token)] = restorechar;
+ 
+ 			if (strlen(highlight) - strlen(token) < strlen(token)) break;
+ 			highlight = fstrstr(highlight + strlen(token), token);
+ 		}
+ 	}
+ }
+ 
+ static int
+ drawitem(struct item *item, int x, int y, int w)
+ {
+ 	if (item == sel)
+ 		drw_setscheme(drw, scheme[SchemeSel]);
+ 	else if (item->out)
+ 		drw_setscheme(drw, scheme[SchemeOut]);
+ 	else
+ 		drw_setscheme(drw, scheme[SchemeNorm]);
+ 
+ 	int r = drw_text(drw, x, y, w, bh, lrpad / 2, item->text, 0);
+ 	drawhighlights(item, x, y, w);
+ 	return r;
+ }
+ 
+ static void
+ drawmenu(void)
+ {
+ 	unsigned int curpos;
+ 	struct item *item;
+ 	int x = 0, y = 0, fh = drw->fonts->h, w;
+ 
+ 	drw_setscheme(drw, scheme[SchemeNorm]);
+ 	drw_rect(drw, 0, 0, mw, mh, 1, 1);
+ 
+ 	if (prompt && *prompt) {
+ 		drw_setscheme(drw, scheme[SchemeSel]);
+ 		x = drw_text(drw, x, 0, promptw, bh, lrpad / 2, prompt, 0);
+ 	}
+ 	/* draw input field */
+ 	w = (lines > 0 || !matches) ? mw - x : inputw;
+ 	drw_setscheme(drw, scheme[SchemeNorm]);
+ 	drw_text(drw, x, 0, w, bh, lrpad / 2, text, 0);
+ 
+ 	curpos = TEXTW(text) - TEXTW(&text[cursor]);
+ 	if ((curpos += lrpad / 2 - 1) < w) {
+ 		drw_setscheme(drw, scheme[SchemeNorm]);
+ 		drw_rect(drw, x + curpos, 2 + (bh - fh) / 2, 2, fh - 4, 1, 0);
+ 	}
+ 
+ 	if (lines > 0) {
+ 		/* draw vertical list */
+ 		for (item = curr; item != next; item = item->right)
+ 			drawitem(item, x, y += bh, mw - x);
+ 	} else if (matches) {
+ 		/* draw horizontal list */
+ 		x += inputw;
+ 		w = TEXTW("<");
+ 		if (curr->left) {
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_text(drw, x, 0, w, bh, lrpad / 2, "<", 0);
+ 		}
+ 		x += w;
+ 		for (item = curr; item != next; item = item->right)
+ 			x = drawitem(item, x, 0, textw_clamp(item->text, mw - x - TEXTW(">")));
+ 		if (next) {
+ 			w = TEXTW(">");
+ 			drw_setscheme(drw, scheme[SchemeNorm]);
+ 			drw_text(drw, mw - w, 0, w, bh, lrpad / 2, ">", 0);
+ 		}
+ 	}
+ 	drw_map(drw, win, 0, 0, mw, mh);
+ }
+ 
+ static void
+ grabfocus(void)
+ {
+ 	struct timespec ts = { .tv_sec = 0, .tv_nsec = 10000000  };
+ 	Window focuswin;
+ 	int i, revertwin;
+ 
+ 	for (i = 0; i < 100; ++i) {
+ 		XGetInputFocus(dpy, &focuswin, &revertwin);
+ 		if (focuswin == win)
+ 			return;
+ 		XSetInputFocus(dpy, win, RevertToParent, CurrentTime);
+ 		nanosleep(&ts, NULL);
+ 	}
+ 	die("cannot grab focus");
+ }
+ 
+ static void
+ grabkeyboard(void)
+ {
+ 	struct timespec ts = { .tv_sec = 0, .tv_nsec = 1000000  };
+ 	int i;
+ 
+ 	if (embed)
+ 		return;
+ 	/* try to grab keyboard, we may have to wait for another process to ungrab */
+ 	for (i = 0; i < 1000; i++) {
+ 		if (XGrabKeyboard(dpy, DefaultRootWindow(dpy), True, GrabModeAsync,
+ 		                  GrabModeAsync, CurrentTime) == GrabSuccess)
+ 			return;
+ 		nanosleep(&ts, NULL);
+ 	}
+ 	die("cannot grab keyboard");
+ }
+ 
+ static void
+ match(void)
+ {
+ 	static char **tokv = NULL;
+ 	static int tokn = 0;
+ 
+ 	char buf[sizeof text], *s;
+ 	int i, tokc = 0;
+ 	size_t len, textsize;
+ 	struct item *item, *lprefix, *lsubstr, *prefixend, *substrend;
+ 
+ 	strcpy(buf, text);
+ 	/* separate input text into tokens to be matched individually */
+ 	for (s = strtok(buf, " "); s; tokv[tokc - 1] = s, s = strtok(NULL, " "))
+ 		if (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))
+ 			die("cannot realloc %zu bytes:", tokn * sizeof *tokv);
+ 	len = tokc ? strlen(tokv[0]) : 0;
+ 
+ 	matches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;
+ 	textsize = strlen(text) + 1;
+ 	for (item = items; item && item->text; item++) {
+ 		for (i = 0; i < tokc; i++)
+ 			if (!fstrstr(item->text, tokv[i]))
+ 				break;
+ 		if (i != tokc) /* not all tokens match */
+ 			continue;
+ 		/* exact matches go first, then prefixes, then substrings */
+ 		if (!tokc || !fstrncmp(text, item->text, textsize))
+ 			appenditem(item, &matches, &matchend);
+ 		else if (!fstrncmp(tokv[0], item->text, len))
+ 			appenditem(item, &lprefix, &prefixend);
+ 		else
+ 			appenditem(item, &lsubstr, &substrend);
+ 	}
+ 	if (lprefix) {
+ 		if (matches) {
+ 			matchend->right = lprefix;
+ 			lprefix->left = matchend;
+ 		} else
+ 			matches = lprefix;
+ 		matchend = prefixend;
+ 	}
+ 	if (lsubstr) {
+ 		if (matches) {
+ 			matchend->right = lsubstr;
+ 			lsubstr->left = matchend;
+ 		} else
+ 			matches = lsubstr;
+ 		matchend = substrend;
+ 	}
+ 	curr = sel = matches;
+ 	calcoffsets();
+ }
+ 
+ static void
+ insert(const char *str, ssize_t n)
+ {
+ 	if (strlen(text) + n > sizeof text - 1)
+ 		return;
+ 	/* move existing text out of the way, insert new text, and update cursor */
+ 	memmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));
+ 	if (n > 0)
+ 		memcpy(&text[cursor], str, n);
+ 	cursor += n;
+ 	match();
+ }
+ 
+ static size_t
+ nextrune(int inc)
+ {
+ 	ssize_t n;
+ 
+ 	/* return location of next utf8 rune in the given direction (+1 or -1) */
+ 	for (n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc)
+ 		;
+ 	return n;
+ }
+ 
+ static void
+ movewordedge(int dir)
+ {
+ 	if (dir < 0) { /* move cursor to the start of the word*/
+ 		while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+ 			cursor = nextrune(-1);
+ 		while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+ 			cursor = nextrune(-1);
+ 	} else { /* move cursor to the end of the word */
+ 		while (text[cursor] && strchr(worddelimiters, text[cursor]))
+ 			cursor = nextrune(+1);
+ 		while (text[cursor] && !strchr(worddelimiters, text[cursor]))
+ 			cursor = nextrune(+1);
+ 	}
+ }
+ 
+ static void
+ keypress(XKeyEvent *ev)
+ {
+ 	char buf[32];
+ 	int len;
+ 	KeySym ksym;
+ 	Status status;
+ 
+ 	len = XmbLookupString(xic, ev, buf, sizeof buf, &ksym, &status);
+ 	switch (status) {
+ 	default: /* XLookupNone, XBufferOverflow */
+ 		return;
+ 	case XLookupChars:
+ 		goto insert;
+ 	case XLookupKeySym:
+ 	case XLookupBoth:
+ 		break;
+ 	}
+ 
+ 	if (ev->state & ControlMask) {
+ 		switch(ksym) {
+ 		case XK_a: ksym = XK_Home;      break;
+ 		case XK_b: ksym = XK_Left;      break;
+ 		case XK_c: ksym = XK_Escape;    break;
+ 		case XK_d: ksym = XK_Delete;    break;
+ 		case XK_e: ksym = XK_End;       break;
+ 		case XK_f: ksym = XK_Right;     break;
+ 		case XK_g: ksym = XK_Escape;    break;
+ 		case XK_h: ksym = XK_BackSpace; break;
+ 		case XK_i: ksym = XK_Tab;       break;
+ 		case XK_j: /* fallthrough */
+ 		case XK_J: /* fallthrough */
+ 		case XK_m: /* fallthrough */
+ 		case XK_M: ksym = XK_Return; ev->state &= ~ControlMask; break;
+ 		case XK_n: ksym = XK_Down;      break;
+ 		case XK_p: ksym = XK_Up;        break;
+ 
+ 		case XK_k: /* delete right */
+ 			text[cursor] = '\0';
+ 			match();
+ 			break;
+ 		case XK_u: /* delete left */
+ 			insert(NULL, 0 - cursor);
+ 			break;
+ 		case XK_w: /* delete word */
+ 			while (cursor > 0 && strchr(worddelimiters, text[nextrune(-1)]))
+ 				insert(NULL, nextrune(-1) - cursor);
+ 			while (cursor > 0 && !strchr(worddelimiters, text[nextrune(-1)]))
+ 				insert(NULL, nextrune(-1) - cursor);
+ 			break;
+ 		case XK_y: /* paste selection */
+ 		case XK_Y:
+ 			XConvertSelection(dpy, (ev->state & ShiftMask) ? clip : XA_PRIMARY,
+ 			                  utf8, utf8, win, CurrentTime);
+ 			return;
+ 		case XK_Left:
+ 		case XK_KP_Left:
+ 			movewordedge(-1);
+ 			goto draw;
+ 		case XK_Right:
+ 		case XK_KP_Right:
+ 			movewordedge(+1);
+ 			goto draw;
+ 		case XK_Return:
+ 		case XK_KP_Enter:
+ 			break;
+ 		case XK_bracketleft:
+ 			cleanup();
+ 			exit(1);
+ 		default:
+ 			return;
+ 		}
+ 	} else if (ev->state & Mod1Mask) {
+ 		switch(ksym) {
+ 		case XK_b:
+ 			movewordedge(-1);
+ 			goto draw;
+ 		case XK_f:
+ 			movewordedge(+1);
+ 			goto draw;
+ 		case XK_g: ksym = XK_Home;  break;
+ 		case XK_G: ksym = XK_End;   break;
+ 		case XK_h: ksym = XK_Up;    break;
+ 		case XK_j: ksym = XK_Next;  break;
+ 		case XK_k: ksym = XK_Prior; break;
+ 		case XK_l: ksym = XK_Down;  break;
+ 		default:
+ 			return;
+ 		}
+ 	}
+ 
+ 	switch(ksym) {
+ 	default:
+ insert:
+ 		if (!iscntrl((unsigned char)*buf))
+ 			insert(buf, len);
+ 		break;
+ 	case XK_Delete:
+ 	case XK_KP_Delete:
+ 		if (text[cursor] == '\0')
+ 			return;
+ 		cursor = nextrune(+1);
+ 		/* fallthrough */
+ 	case XK_BackSpace:
+ 		if (cursor == 0)
+ 			return;
+ 		insert(NULL, nextrune(-1) - cursor);
+ 		break;
+ 	case XK_End:
+ 	case XK_KP_End:
+ 		if (text[cursor] != '\0') {
+ 			cursor = strlen(text);
+ 			break;
+ 		}
+ 		if (next) {
+ 			/* jump to end of list and position items in reverse */
+ 			curr = matchend;
+ 			calcoffsets();
+ 			curr = prev;
+ 			calcoffsets();
+ 			while (next && (curr = curr->right))
+ 				calcoffsets();
+ 		}
+ 		sel = matchend;
+ 		break;
+ 	case XK_Escape:
+ 		cleanup();
+ 		exit(1);
+ 	case XK_Home:
+ 	case XK_KP_Home:
+ 		if (sel == matches) {
+ 			cursor = 0;
+ 			break;
+ 		}
+ 		sel = curr = matches;
+ 		calcoffsets();
+ 		break;
+ 	case XK_Left:
+ 	case XK_KP_Left:
+ 		if (cursor > 0 && (!sel || !sel->left || lines > 0)) {
+ 			cursor = nextrune(-1);
+ 			break;
+ 		}
+ 		if (lines > 0)
+ 			return;
+ 		/* fallthrough */
+ 	case XK_Up:
+ 	case XK_KP_Up:
+ 		if (sel && sel->left && (sel = sel->left)->right == curr) {
+ 			curr = prev;
+ 			calcoffsets();
+ 		}
+ 		break;
+ 	case XK_Next:
+ 	case XK_KP_Next:
+ 		if (!next)
+ 			return;
+ 		sel = curr = next;
+ 		calcoffsets();
+ 		break;
+ 	case XK_Prior:
+ 	case XK_KP_Prior:
+ 		if (!prev)
+ 			return;
+ 		sel = curr = prev;
+ 		calcoffsets();
+ 		break;
+ 	case XK_Return:
+ 	case XK_KP_Enter:
+ 		puts((sel && !(ev->state & ShiftMask)) ? sel->otext : text);
+ 		if (!(ev->state & ControlMask)) {
+ 			cleanup();
+ 			exit(0);
+ 		}
+ 		if (sel)
+ 			sel->out = 1;
+ 		break;
+ 	case XK_Right:
+ 	case XK_KP_Right:
+ 		if (text[cursor] != '\0') {
+ 			cursor = nextrune(+1);
+ 			break;
+ 		}
+ 		if (lines > 0)
+ 			return;
+ 		/* fallthrough */
+ 	case XK_Down:
+ 	case XK_KP_Down:
+ 		if (sel && sel->right && (sel = sel->right) == next) {
+ 			curr = next;
+ 			calcoffsets();
+ 		}
+ 		break;
+ 	case XK_Tab:
+ 		if (!sel)
+ 			return;
+ 		cursor = strnlen(sel->text, sizeof text - 1);
+ 		memcpy(text, sel->text, cursor);
+ 		text[cursor] = '\0';
+ 		match();
+ 		break;
+ 	}
+ 
+ draw:
+ 	drawmenu();
+ }
+ 
+ static void
+ paste(void)
+ {
+ 	char *p, *q;
+ 	int di;
+ 	unsigned long dl;
+ 	Atom da;
+ 
+ 	/* we have been given the current selection, now insert it into input */
+ 	if (XGetWindowProperty(dpy, win, utf8, 0, (sizeof text / 4) + 1, False,
+ 	                   utf8, &da, &di, &dl, &dl, (unsigned char **)&p)
+ 	    == Success && p) {
+ 		insert(p, (q = strchr(p, '\n')) ? q - p : (ssize_t)strlen(p));
+ 		XFree(p);
+ 	}
+ 	drawmenu();
+ }
+ 
+ static void
+ readstdin(void)
+ {
+ 	char *line = NULL;
+ 	size_t i, junk, size = 0;
+ 	ssize_t len;
+ 
+ 	/* read each line from stdin and add it to the item list */
+ 	for (i = 0; (len = getline(&line, &junk, stdin)) != -1; i++, line = NULL) {
+ 		if (i + 1 >= size / sizeof *items)
+ 			if (!(items = realloc(items, (size += BUFSIZ))))
+ 				die("cannot realloc %zu bytes:", size);
+ 		if (line[len - 1] == '\n')
+ 			line[len - 1] = '\0';
+ 		items[i].text = items[i].otext = line;
+ 		if ((line = strchr(line, '\t'))) {
+ 			*line++ = '\0';
+ 			revtab ? (items[i].text = line) : (items[i].otext = line);
+ 		}
+ 		items[i].out = 0;
+ 	}
+ 	if (items)
+ 		items[i].text = items[i].otext = NULL;
+ 	lines = MIN(lines, i);
+ }
+ 
+ static void
+ run(void)
+ {
+ 	XEvent ev;
+ 
+ 	while (!XNextEvent(dpy, &ev)) {
+ 		if (XFilterEvent(&ev, win))
+ 			continue;
+ 		switch(ev.type) {
+ 		case DestroyNotify:
+ 			if (ev.xdestroywindow.window != win)
+ 				break;
+ 			cleanup();
+ 			exit(1);
+ 		case Expose:
+ 			if (ev.xexpose.count == 0)
+ 				drw_map(drw, win, 0, 0, mw, mh);
+ 			break;
+ 		case FocusIn:
+ 			/* regrab focus from parent window */
+ 			if (ev.xfocus.window != win)
+ 				grabfocus();
+ 			break;
+ 		case KeyPress:
+ 			keypress(&ev.xkey);
+ 			break;
+ 		case SelectionNotify:
+ 			if (ev.xselection.property == utf8)
+ 				paste();
+ 			break;
+ 		case VisibilityNotify:
+ 			if (ev.xvisibility.state != VisibilityUnobscured)
+ 				XRaiseWindow(dpy, win);
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static void
+ setup(void)
+ {
+ 	int x, y, i, j;
+ 	unsigned int du;
+ 	XSetWindowAttributes swa;
+ 	XIM xim;
+ 	Window w, dw, *dws;
+ 	XWindowAttributes wa;
+ 	XClassHint ch = {"dmenu", "dmenu"};
+ #ifdef XINERAMA
+ 	XineramaScreenInfo *info;
+ 	Window pw;
+ 	int a, di, n, area = 0;
+ #endif
+ 	/* init appearance */
+ 	for (j = 0; j < SchemeLast; j++) {
+ 		scheme[j] = drw_scm_create(drw, (const char**)colors[j], 2);
+ 	}
+ 	for (j = 0; j < SchemeOut; ++j) {
+ 		for (i = 0; i < 2; ++i)
+ 			free(colors[j][i]);
+ 	}
+ 
+ 	clip = XInternAtom(dpy, "CLIPBOARD",   False);
+ 	utf8 = XInternAtom(dpy, "UTF8_STRING", False);
+ 
+ 	/* calculate menu geometry */
+ 	bh = drw->fonts->h + 2;
+ 	bh = MAX(bh,lineheight);	/* make a menu line AT LEAST 'lineheight' tall */
+ 	lines = MAX(lines, 0);
+ 	mh = (lines + 1) * bh;
+ 	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+ #ifdef XINERAMA
+ 	i = 0;
+ 	if (parentwin == root && (info = XineramaQueryScreens(dpy, &n))) {
+ 		XGetInputFocus(dpy, &w, &di);
+ 		if (mon >= 0 && mon < n)
+ 			i = mon;
+ 		else if (w != root && w != PointerRoot && w != None) {
+ 			/* find top-level window containing current input focus */
+ 			do {
+ 				if (XQueryTree(dpy, (pw = w), &dw, &w, &dws, &du) && dws)
+ 					XFree(dws);
+ 			} while (w != root && w != pw);
+ 			/* find xinerama screen with which the window intersects most */
+ 			if (XGetWindowAttributes(dpy, pw, &wa))
+ 				for (j = 0; j < n; j++)
+ 					if ((a = INTERSECT(wa.x, wa.y, wa.width, wa.height, info[j])) > area) {
+ 						area = a;
+ 						i = j;
+ 					}
+ 		}
+ 		/* no focused window is on screen, so use pointer location instead */
+ 		if (mon < 0 && !area && XQueryPointer(dpy, root, &dw, &dw, &x, &y, &di, &di, &du))
+ 			for (i = 0; i < n; i++)
+ 				if (INTERSECT(x, y, 1, 1, info[i]) != 0)
+ 					break;
+ 
+         if (centered) {
+             mw = MIN(MAX(max_textw() + promptw, min_width), info[i].width);
+ 			x = info[i].x_org + ((info[i].width  - mw) / 2);
+ 			y = info[i].y_org + ((info[i].height - mh) / 2);
+         } else {
+ 		    x = info[i].x_org + dmx;
+ 		    y = info[i].y_org + (topbar ? dmy : info[i].height - mh - dmy);
+ 		    mw = (dmw>0 ? dmw : info[i].width);
+         }
+ 		XFree(info);
+ 	} else
+ #endif
+ 	{
+ 		if (!XGetWindowAttributes(dpy, parentwin, &wa))
+ 			die("could not get embedding window attributes: 0x%lx",
+ 			    parentwin);
+         if (centered) {
+             mw = MIN(MAX(max_textw() + promptw, min_width), wa.width);
+ 			x = (wa.width  - mw) / 2;
+ 			y = (wa.height - mh) / 2;
+         } else {
+ 		    x = dmx;
+ 		    y = topbar ? dmy : wa.height - mh - dmy;
+ 		    mw = (dmw>0 ? dmw : wa.width);
+         }
+ 	}
+ 	promptw = (prompt && *prompt) ? TEXTW(prompt) - lrpad / 4 : 0;
+ 	inputw = mw / 3; /* input width: ~33% of monitor width */
+ 	match();
+ 
+ 	/* create menu window */
+ 	swa.override_redirect = True;
+ 	swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+ 	swa.event_mask = ExposureMask | KeyPressMask | VisibilityChangeMask;
+ 	win = XCreateWindow(dpy, parentwin, x, y, mw, mh, border_width,
+ 	                    CopyFromParent, CopyFromParent, CopyFromParent,
+ 	                    CWOverrideRedirect | CWBackPixel | CWEventMask, &swa);
+ 	if (border_width)
+ 		XSetWindowBorder(dpy, win, scheme[SchemeSel][ColBg].pixel);
+ 	XSetClassHint(dpy, win, &ch);
+ 
+ 
+ 	/* input methods */
+ 	if ((xim = XOpenIM(dpy, NULL, NULL, NULL)) == NULL)
+ 		die("XOpenIM failed: could not open input device");
+ 
+ 	xic = XCreateIC(xim, XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+ 	                XNClientWindow, win, XNFocusWindow, win, NULL);
+ 
+ 	XMapRaised(dpy, win);
+ 	if (embed) {
+ 		XSelectInput(dpy, parentwin, FocusChangeMask | SubstructureNotifyMask);
+ 		if (XQueryTree(dpy, parentwin, &dw, &w, &dws, &du) && dws) {
+ 			for (i = 0; i < du && dws[i] != win; ++i)
+ 				XSelectInput(dpy, dws[i], FocusChangeMask);
+ 			XFree(dws);
+ 		}
+ 		grabfocus();
+ 	}
+ 	drw_resize(drw, mw, mh);
+ 	drawmenu();
+ }
+ 
+ static void
+ usage(void)
+ {
+ 	die("usage: dmenu [-bfivr] [-l lines] [-h height] [-p prompt] [-fn font] [-m monitor]\n"
+         "             [-x xoffset] [-y yoffset] [-z width]\n"
+ 	    "             [-nb color] [-nf color] [-sb color] [-sf color] [-w windowid]");
+ }
+ 
+ void
+ readxresources(void) {
+ 	XrmInitialize();
+ 
+ 	char* xrm;
+ 	if ((xrm = XResourceManagerString(drw->dpy))) {
+ 		char *type;
+ 		XrmDatabase xdb = XrmGetStringDatabase(xrm);
+ 		XrmValue xval;
+ 
+ 		if (XrmGetResource(xdb, "dmenu.font", "*", &type, &xval))
+ 			fonts[0] = strdup(xval.addr);
+ 		else
+ 			fonts[0] = strdup(fonts[0]);
+ 		if (XrmGetResource(xdb, "dmenu.background", "*", &type, &xval))
+ 			colors[SchemeNorm][ColBg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeNorm][ColBg] = strdup(colors[SchemeNorm][ColBg]);
+ 		if (XrmGetResource(xdb, "dmenu.foreground", "*", &type, &xval))
+ 			colors[SchemeNorm][ColFg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeNorm][ColFg] = strdup(colors[SchemeNorm][ColFg]);
+ 		if (XrmGetResource(xdb, "dmenu.selbackground", "*", &type, &xval))
+ 			colors[SchemeSel][ColBg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeSel][ColBg] = strdup(colors[SchemeSel][ColBg]);
+ 		if (XrmGetResource(xdb, "dmenu.selforeground", "*", &type, &xval))
+ 			colors[SchemeSel][ColFg] = strdup(xval.addr);
+ 		else
+ 			colors[SchemeSel][ColFg] = strdup(colors[SchemeSel][ColFg]);
+ 
+ 		XrmDestroyDatabase(xdb);
+ 	}
+ }
+ 
+ int
+ main(int argc, char *argv[])
+ {
+ 	XWindowAttributes wa;
+ 	int i, fast = 0;
+ 
+ 	for (i = 1; i < argc; i++)
+ 		/* these options take no arguments */
+ 		if (!strcmp(argv[i], "-v")) {      /* prints version information */
+ 			puts("dmenu-"VERSION);
+ 			exit(0);
+ 		} else if (!strcmp(argv[i], "-b")) /* appears at the bottom of the screen */
+ 			topbar = 0;
+ 		else if (!strcmp(argv[i], "-f"))   /* grabs keyboard before reading stdin */
+ 			fast = 1;
+ 		else if (!strcmp(argv[i], "-c"))   /* centers dmenu on screen */
+ 			centered = 1;
+ 		else if (!strcmp(argv[i], "-i")) { /* case-insensitive item matching */
+ 			fstrncmp = strncasecmp;
+ 			fstrstr = cistrstr;
+ 		} else if (!strcmp(argv[i], "-r")) /* reverse the tab separation */
+ 			revtab = (!revtab);
+ 		else if (i + 1 == argc)
+ 			usage();
+ 		/* these options take one argument */
+ 		else if (!strcmp(argv[i], "-l"))   /* number of lines in vertical list */
+ 			lines = atoi(argv[++i]);
+         else if (!strcmp(argv[i], "-x"))   /* window x offset */
+ 			dmx = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-y"))   /* window y offset (from bottom up if -b) */
+ 			dmy = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-z"))   /* make dmenu this wide */
+ 			dmw = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-h")) { /* minimum height of one menu line */
+ 			lineheight = atoi(argv[++i]);
+ 			lineheight = MAX(lineheight, min_lineheight);
+ 		}
+ 		else if (!strcmp(argv[i], "-m"))
+ 			mon = atoi(argv[++i]);
+ 		else if (!strcmp(argv[i], "-p"))   /* adds prompt to left of input field */
+ 			prompt = argv[++i];
+ 		else if (!strcmp(argv[i], "-fn"))  /* font or font set */
+ 			tempfonts = argv[++i];
+ 		else if (!strcmp(argv[i], "-nb"))  /* normal background color */
+ 			colortemp[0] = argv[++i];
+ 		else if (!strcmp(argv[i], "-nf"))  /* normal foreground color */
+ 			colortemp[1] = argv[++i];
+ 		else if (!strcmp(argv[i], "-sb"))  /* selected background color */
+ 			colortemp[2] = argv[++i];
+ 		else if (!strcmp(argv[i], "-sf"))  /* selected foreground color */
+ 			colortemp[3] = argv[++i];
+ 		else if (!strcmp(argv[i], "-w"))   /* embedding window id */
+ 			embed = argv[++i];
+ 		else if (!strcmp(argv[i], "-bw"))
+ 			border_width = atoi(argv[++i]); /* border width */
+ 		else
+ 			usage();
+ 
+ 	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+ 		fputs("warning: no locale support\n", stderr);
+ 	if (!(dpy = XOpenDisplay(NULL)))
+ 		die("cannot open display");
+ 	screen = DefaultScreen(dpy);
+ 	root = RootWindow(dpy, screen);
+ 	if (!embed || !(parentwin = strtol(embed, NULL, 0)))
+ 		parentwin = root;
+ 	if (!XGetWindowAttributes(dpy, parentwin, &wa))
+ 		die("could not get embedding window attributes: 0x%lx",
+ 		    parentwin);
+ 	drw = drw_create(dpy, screen, root, wa.width, wa.height);
+ 	readxresources();
+ 	/* Now we check whether to override xresources with commandline parameters */
+ 	if ( tempfonts )
+ 	   fonts[0] = strdup(tempfonts);
+ 	if ( colortemp[0])
+ 	   colors[SchemeNorm][ColBg] = strdup(colortemp[0]);
+ 	if ( colortemp[1])
+ 	   colors[SchemeNorm][ColFg] = strdup(colortemp[1]);
+ 	if ( colortemp[2])
+ 	   colors[SchemeSel][ColBg]  = strdup(colortemp[2]);
+ 	if ( colortemp[3])
+ 	   colors[SchemeSel][ColFg]  = strdup(colortemp[3]);
+ 
+ 	if (!drw_fontset_create(drw, (const char**)fonts, LENGTH(fonts)))
+ 		die("no fonts could be loaded.");
+ 
+ 	free(fonts[0]);
+ 	lrpad = drw->fonts->h;
+ 
+ #ifdef __OpenBSD__
+ 	if (pledge("stdio rpath", NULL) == -1)
+ 		die("pledge");
+ #endif
+ 
+ 	if (fast && !isatty(0)) {
+ 		grabkeyboard();
+ 		readstdin();
+ 	} else {
+ 		readstdin();
+ 		grabkeyboard();
+ 	}
+ 	setup();
+ 	run();
+ 
+ 	return 1; /* unreachable */
+ }
